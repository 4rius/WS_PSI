digraph "classes" {
rankdir=BT
charset="utf-8"
"damgard_jurik.crypto.PrivateKeyRing" [color="black", fontcolor="black", label=<{damgard_jurik.crypto.PrivateKeyRing|S : set<br ALIGN="LEFT"/>i_list<br ALIGN="LEFT"/>inv_four_delta_squared<br ALIGN="LEFT"/>private_key_shares<br ALIGN="LEFT"/>public_key<br ALIGN="LEFT"/>|decrypt(c: EncryptedNumber): int<br ALIGN="LEFT"/>decrypt_list(c_list: List[EncryptedNumber]): List[int]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"damgard_jurik.crypto.PublicKey" [color="black", fontcolor="black", label=<{damgard_jurik.crypto.PublicKey|delta : int<br ALIGN="LEFT"/>m : int<br ALIGN="LEFT"/>n : int<br ALIGN="LEFT"/>n_s<br ALIGN="LEFT"/>n_s_1<br ALIGN="LEFT"/>n_s_m<br ALIGN="LEFT"/>s : int<br ALIGN="LEFT"/>threshold : int<br ALIGN="LEFT"/>|encrypt(m: int): EncryptedNumber<br ALIGN="LEFT"/>encrypt_list(m_list: List[int]): List[EncryptedNumber]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"flaskr.Logs.ThreadData" [color="black", fontcolor="black", label=<{flaskr.Logs.ThreadData|avg_cpu_usage : int<br ALIGN="LEFT"/>avg_instance_cpu_usage : int<br ALIGN="LEFT"/>avg_instance_ram_usage : int<br ALIGN="LEFT"/>avg_ram_usage : int<br ALIGN="LEFT"/>cpu_usage : list<br ALIGN="LEFT"/>instance_cpu_usage : list<br ALIGN="LEFT"/>instance_ram_usage : list<br ALIGN="LEFT"/>peak_cpu_usage : int<br ALIGN="LEFT"/>peak_instance_cpu_usage : int<br ALIGN="LEFT"/>peak_instance_ram_usage : int<br ALIGN="LEFT"/>peak_ram_usage : int<br ALIGN="LEFT"/>ram_usage : list<br ALIGN="LEFT"/>stop_event : Event<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"flaskr.Node.Node" [color="black", fontcolor="black", label=<{flaskr.Node.Node|context<br ALIGN="LEFT"/>devices : dict<br ALIGN="LEFT"/>domain : int<br ALIGN="LEFT"/>executor : ThreadPoolExecutor<br ALIGN="LEFT"/>id<br ALIGN="LEFT"/>myData : set<br ALIGN="LEFT"/>peers<br ALIGN="LEFT"/>port<br ALIGN="LEFT"/>results : dict<br ALIGN="LEFT"/>router_socket<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>scheme_handler<br ALIGN="LEFT"/>|broadcast_message(message)<br ALIGN="LEFT"/>connect_to_peers()<br ALIGN="LEFT"/>discover_peers()<br ALIGN="LEFT"/>dj_intersection_first_step(device)<br ALIGN="LEFT"/>dj_intersection_first_step_ope(device, type)<br ALIGN="LEFT"/>gen_dj()<br ALIGN="LEFT"/>gen_paillier()<br ALIGN="LEFT"/>get_devices()<br ALIGN="LEFT"/>handle_added(message, day_time)<br ALIGN="LEFT"/>handle_discover(message, day_time)<br ALIGN="LEFT"/>handle_discover_ack(message, day_time)<br ALIGN="LEFT"/>handle_intersection(message)<br ALIGN="LEFT"/>handle_message(sender, message, day_time)<br ALIGN="LEFT"/>handle_ping(sender, message, day_time)<br ALIGN="LEFT"/>handle_unknown(message, day_time)<br ALIGN="LEFT"/>intersection_second_step(message)<br ALIGN="LEFT"/>launch_test(device)<br ALIGN="LEFT"/>new_peer(peer, last_seen)<br ALIGN="LEFT"/>paillier_intersection_first_step(device)<br ALIGN="LEFT"/>paillier_intersection_first_step_ope(device, type)<br ALIGN="LEFT"/>ping_device(device)<br ALIGN="LEFT"/>send_message(peer_data, set, cryptpscheme)<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>start_router_socket()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"flaskr.handlers.SchemeHandler.SchemeHandler" [color="black", fontcolor="black", label=<{flaskr.handlers.SchemeHandler.SchemeHandler|damgard_jurik<br ALIGN="LEFT"/>devices<br ALIGN="LEFT"/>domain<br ALIGN="LEFT"/>id<br ALIGN="LEFT"/>my_data<br ALIGN="LEFT"/>paillier<br ALIGN="LEFT"/>results<br ALIGN="LEFT"/>|final_step_psi_ca_ope(device, cs, peer_data)<br ALIGN="LEFT"/>genkeys(cs)<br ALIGN="LEFT"/>handle_intersection(device, cs, peer_data, pubkey)<br ALIGN="LEFT"/>handle_ope(device, cs, peer_data, coeffs, pubkey)<br ALIGN="LEFT"/>handle_psi_ca_ope(device, cs, coeffs, pubkey)<br ALIGN="LEFT"/>intersection_final_step(device, cs, peer_data)<br ALIGN="LEFT"/>intersection_final_step_ope(device, cs, peer_data)<br ALIGN="LEFT"/>intersection_first_step(device, cs)<br ALIGN="LEFT"/>intersection_first_step_ope(device, cs, type)<br ALIGN="LEFT"/>test_launcher(device)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"flaskr.implementations.CryptoSystem.CryptoSystem" [color="black", fontcolor="black", label=<{flaskr.implementations.CryptoSystem.CryptoSystem|<br ALIGN="LEFT"/>|<I>decrypt</I>(ciphertext)<br ALIGN="LEFT"/><I>encrypt</I>(plaintext)<br ALIGN="LEFT"/><I>encrypt_my_data</I>(my_set, domain)<br ALIGN="LEFT"/><I>eval_coefficients</I>(coeffs, pubkey, my_data)<br ALIGN="LEFT"/><I>generate_keys</I>()<br ALIGN="LEFT"/><I>get_ciphertext</I>(encrypted_number)<br ALIGN="LEFT"/><I>get_encrypted_list</I>(serialized_encrypted_list, public_key)<br ALIGN="LEFT"/><I>get_encrypted_list_f</I>(serialized_encrypted_list)<br ALIGN="LEFT"/><I>get_encrypted_set</I>(serialized_encrypted_set, public_key)<br ALIGN="LEFT"/><I>get_evaluations</I>(coeffs, pubkey, my_data)<br ALIGN="LEFT"/><I>get_multiplied_set</I>(enc_set, node_set)<br ALIGN="LEFT"/><I>horner_encrypted_eval</I>(coeffs, x)<br ALIGN="LEFT"/><I>intersection_enc_size</I>(multiplied_set)<br ALIGN="LEFT"/><I>multiply_encrypted_sets</I>(encrypted_set1, encrypted_set2)<br ALIGN="LEFT"/><I>reconstruct_public_key</I>(public_key_dict)<br ALIGN="LEFT"/><I>recv_multiplied_set</I>(serialized_multiplied_set, public_key)<br ALIGN="LEFT"/><I>serialize_public_key</I>()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"flaskr.implementations.Damgard_jurik.DamgardJurik" [color="black", fontcolor="black", label=<{flaskr.implementations.Damgard_jurik.DamgardJurik|private_key_ring : NoneType<br ALIGN="LEFT"/>public_key : NoneType<br ALIGN="LEFT"/>|decrypt(number)<br ALIGN="LEFT"/>encrypt(number)<br ALIGN="LEFT"/>encrypt_my_data(my_set, domain)<br ALIGN="LEFT"/>eval_coefficients(coefs, pubkey, my_data)<br ALIGN="LEFT"/>generate_keys()<br ALIGN="LEFT"/>get_ciphertext(encrypted_number)<br ALIGN="LEFT"/>get_encrypted_list(serialized_encrypted_list, public_key)<br ALIGN="LEFT"/>get_encrypted_list_f(serialized_encrypted_list)<br ALIGN="LEFT"/>get_encrypted_set(serialized_encrypted_set, public_key)<br ALIGN="LEFT"/>get_evaluations(coefs, pubkey, my_data)<br ALIGN="LEFT"/>get_multiplied_set(enc_set, node_set)<br ALIGN="LEFT"/>horner_encrypted_eval(coefs, x)<br ALIGN="LEFT"/>intersection_enc_size(multiplied_set)<br ALIGN="LEFT"/>reconstruct_public_key(public_key_dict)<br ALIGN="LEFT"/>recv_multiplied_set(serialized_multiplied_set, public_key)<br ALIGN="LEFT"/>serialize_public_key()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"flaskr.implementations.Paillier.Paillier" [color="black", fontcolor="black", label=<{flaskr.implementations.Paillier.Paillier|private_key : NoneType<br ALIGN="LEFT"/>public_key : NoneType<br ALIGN="LEFT"/>|decrypt(encrypted_number)<br ALIGN="LEFT"/>encrypt(number)<br ALIGN="LEFT"/>encrypt_my_data(my_set, domain)<br ALIGN="LEFT"/>eval_coefficients(coeffs, pubkey, my_data)<br ALIGN="LEFT"/>generate_keys()<br ALIGN="LEFT"/>get_ciphertext(encrypted_number)<br ALIGN="LEFT"/>get_encrypted_list(serialized_encrypted_list, public_key)<br ALIGN="LEFT"/>get_encrypted_list_f(serialized_encrypted_list)<br ALIGN="LEFT"/>get_encrypted_set(serialized_encrypted_set, public_key)<br ALIGN="LEFT"/>get_evaluations(coeffs, pubkey, my_data)<br ALIGN="LEFT"/>get_multiplied_set(enc_set, node_set)<br ALIGN="LEFT"/>horner_encrypted_eval(coeffs, x)<br ALIGN="LEFT"/>intersection_enc_size(multiplied_set)<br ALIGN="LEFT"/>reconstruct_public_key(public_key_dict)<br ALIGN="LEFT"/>recv_multiplied_set(serialized_multiplied_set, public_key)<br ALIGN="LEFT"/>serialize_public_key()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"phe.paillier.PaillierPrivateKey" [color="black", fontcolor="black", label=<{phe.paillier.PaillierPrivateKey|hp : int<br ALIGN="LEFT"/>hq : int<br ALIGN="LEFT"/>p<br ALIGN="LEFT"/>p_inverse : int<br ALIGN="LEFT"/>psquare<br ALIGN="LEFT"/>public_key<br ALIGN="LEFT"/>q<br ALIGN="LEFT"/>qsquare<br ALIGN="LEFT"/>|crt(mp, mq)<br ALIGN="LEFT"/>decrypt(encrypted_number)<br ALIGN="LEFT"/>decrypt_encoded(encrypted_number, Encoding)<br ALIGN="LEFT"/>from_totient(public_key, totient)<br ALIGN="LEFT"/>h_function(x, xsquare)<br ALIGN="LEFT"/>l_function(x, p)<br ALIGN="LEFT"/>raw_decrypt(ciphertext)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"phe.paillier.PaillierPublicKey" [color="black", fontcolor="black", label=<{phe.paillier.PaillierPublicKey|g<br ALIGN="LEFT"/>max_int<br ALIGN="LEFT"/>n<br ALIGN="LEFT"/>nsquare<br ALIGN="LEFT"/>|encrypt(value, precision, r_value)<br ALIGN="LEFT"/>encrypt_encoded(encoding, r_value)<br ALIGN="LEFT"/>get_random_lt_n()<br ALIGN="LEFT"/>raw_encrypt(plaintext, r_value)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"zmq.sugar.attrsettr.AttributeSetter" [color="black", fontcolor="black", label=<{zmq.sugar.attrsettr.AttributeSetter|<br ALIGN="LEFT"/>|<I>get</I>(opt: int): OptValT<br ALIGN="LEFT"/><I>set</I>(opt: int, val: OptValT): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"zmq.sugar.context.Context" [color="black", fontcolor="black", label=<{zmq.sugar.context.Context|sockopts : Dict[int, Any]<br ALIGN="LEFT"/>|destroy(linger: Optional[int]): None<br ALIGN="LEFT"/>getsockopt(opt: int): OptValT<br ALIGN="LEFT"/>instance(io_threads: int): T<br ALIGN="LEFT"/>setsockopt(opt: int, value: Any): None<br ALIGN="LEFT"/>shadow(address: Union[int, 'Context']): T<br ALIGN="LEFT"/>shadow_pyczmq(ctx: Any): T<br ALIGN="LEFT"/>socket(socket_type: int, socket_class: Optional[Callable[[T, int], ST]]): ST<br ALIGN="LEFT"/>term(): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"zmq.sugar.poll.Poller" [color="black", fontcolor="black", label=<{zmq.sugar.poll.Poller|sockets : List[Tuple[Any, int]]<br ALIGN="LEFT"/>|modify(socket, flags)<br ALIGN="LEFT"/>poll(timeout: Optional[int]): List[Tuple[Any, int]]<br ALIGN="LEFT"/>register(socket: Any, flags: int)<br ALIGN="LEFT"/>unregister(socket: Any)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"zmq.sugar.socket.Socket" [color="black", fontcolor="black", label=<{zmq.sugar.socket.Socket|getsockopt<br ALIGN="LEFT"/>getsockopt_string<br ALIGN="LEFT"/>getsockopt_unicode<br ALIGN="LEFT"/>hwm<br ALIGN="LEFT"/>rcvhwm<br ALIGN="LEFT"/>recv_unicode<br ALIGN="LEFT"/>send_unicode<br ALIGN="LEFT"/>setsockopt<br ALIGN="LEFT"/>setsockopt_string<br ALIGN="LEFT"/>setsockopt_unicode<br ALIGN="LEFT"/>sndhwm<br ALIGN="LEFT"/>socket_type<br ALIGN="LEFT"/>|bind(addr: str): _SocketContext[T]<br ALIGN="LEFT"/>bind_to_random_port(addr: str, min_port: int, max_port: int, max_tries: int): int<br ALIGN="LEFT"/>close(linger): None<br ALIGN="LEFT"/>connect(addr: str): _SocketContext[T]<br ALIGN="LEFT"/>disable_monitor(): None<br ALIGN="LEFT"/>fileno(): int<br ALIGN="LEFT"/>get_hwm(): int<br ALIGN="LEFT"/>get_monitor_socket(events: Optional[int], addr: Optional[str]): T<br ALIGN="LEFT"/>get_string(option: int, encoding): str<br ALIGN="LEFT"/>poll(timeout, flags): int<br ALIGN="LEFT"/>recv_json(flags: int): Union[List, str, int, float, Dict]<br ALIGN="LEFT"/>recv_multipart(flags: int): List[bytes]<br ALIGN="LEFT"/>recv_pyobj(flags: int): Any<br ALIGN="LEFT"/>recv_serialized(deserialize, flags, copy)<br ALIGN="LEFT"/>recv_string(flags: int, encoding: str): str<br ALIGN="LEFT"/>send(data: Any, flags: int, copy: bool): 'zmq.MessageTracker'<br ALIGN="LEFT"/>send_json(obj: Any, flags: int): None<br ALIGN="LEFT"/>send_multipart(msg_parts: Sequence, flags: int, copy: bool, track: bool)<br ALIGN="LEFT"/>send_pyobj(obj: Any, flags: int, protocol: int): Optional[zmq.Frame]<br ALIGN="LEFT"/>send_serialized(msg, serialize, flags, copy)<br ALIGN="LEFT"/>send_string(u: str, flags: int, copy: bool, encoding: str): Optional['zmq.Frame']<br ALIGN="LEFT"/>set_hwm(value: int): None<br ALIGN="LEFT"/>set_string(option: int, optval: str, encoding): None<br ALIGN="LEFT"/>shadow(address: Union[int, 'zmq.Socket']): T<br ALIGN="LEFT"/>subscribe(topic: Union[str, bytes]): None<br ALIGN="LEFT"/>unsubscribe(topic: Union[str, bytes]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"flaskr.implementations.Damgard_jurik.DamgardJurik" -> "flaskr.implementations.CryptoSystem.CryptoSystem" [arrowhead="empty", arrowtail="none"];
"flaskr.implementations.Paillier.Paillier" -> "flaskr.implementations.CryptoSystem.CryptoSystem" [arrowhead="empty", arrowtail="none"];
"zmq.sugar.context.Context" -> "zmq.sugar.attrsettr.AttributeSetter" [arrowhead="empty", arrowtail="none"];
"zmq.sugar.socket.Socket" -> "zmq.sugar.attrsettr.AttributeSetter" [arrowhead="empty", arrowtail="none"];
"damgard_jurik.crypto.PrivateKeyRing" -> "flaskr.implementations.Damgard_jurik.DamgardJurik" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="private_key_ring", style="solid"];
"damgard_jurik.crypto.PublicKey" -> "flaskr.implementations.Damgard_jurik.DamgardJurik" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="public_key", style="solid"];
"flaskr.handlers.SchemeHandler.SchemeHandler" -> "flaskr.Node.Node" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scheme_handler", style="solid"];
"flaskr.implementations.Damgard_jurik.DamgardJurik" -> "flaskr.handlers.SchemeHandler.SchemeHandler" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="damgard_jurik", style="solid"];
"flaskr.implementations.Paillier.Paillier" -> "flaskr.handlers.SchemeHandler.SchemeHandler" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="paillier", style="solid"];
"phe.paillier.PaillierPrivateKey" -> "flaskr.implementations.Paillier.Paillier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="private_key", style="solid"];
"phe.paillier.PaillierPublicKey" -> "flaskr.implementations.Paillier.Paillier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="public_key", style="solid"];
"zmq.sugar.context.Context" -> "flaskr.Node.Node" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="context", style="solid"];
"zmq.sugar.poll.Poller" -> "zmq.sugar.socket.Socket" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_poller_class", style="solid"];
"zmq.sugar.socket.Socket" -> "flaskr.Node.Node" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="router_socket", style="solid"];
}
